<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="simple life"><title>Linux中的文件I/O缓冲 | LITREILY</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux中的文件I/O缓冲</h1><a id="logo" href="/.">LITREILY</a><p class="description">Stay Hungry, Stay Foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="https://litreily.gitbooks.io/notes/"><i class="fa fa-book"> Notes</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/history/"><i class="fa fa-history"> History</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux中的文件I/O缓冲</h1><div class="post-meta">Oct 25, 2018<span> | </span><span class="category"><a href="/categories/Linux/">Linux</a></span></div><a class="disqus-comment-count" href="/2018/10/25/io-cache/#vcomment"><span class="valine-comment-count" data-xid="/2018/10/25/io-cache/"></span><span> Comment</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O缓冲的类型"><span class="toc-number">1.</span> <span class="toc-text">I/O缓冲的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stdio库的缓冲"><span class="toc-number">1.1.</span> <span class="toc-text">stdio库的缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件I-O的内核缓冲"><span class="toc-number">1.2.</span> <span class="toc-text">文件I/O的内核缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘驱动器内置缓冲"><span class="toc-number">1.3.</span> <span class="toc-text">磁盘驱动器内置缓冲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#控制文件I-O缓冲"><span class="toc-number">2.</span> <span class="toc-text">控制文件I/O缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#控制stdio库的缓冲"><span class="toc-number">2.1.</span> <span class="toc-text">控制stdio库的缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制文件I-O的内核缓冲"><span class="toc-number">2.2.</span> <span class="toc-text">控制文件I/O的内核缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fsync"><span class="toc-number">2.2.1.</span> <span class="toc-text">fsync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-SYNC"><span class="toc-number">2.2.2.</span> <span class="toc-text">O_SYNC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#禁用磁盘高速缓存"><span class="toc-number">2.3.</span> <span class="toc-text">禁用磁盘高速缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直接I-O"><span class="toc-number">2.4.</span> <span class="toc-text">直接I/O</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-number">4.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="post-content"><p>近日阅读《Linux/UNIX系统编程手册》第13章 - 文件I/O缓冲，有些收获，是以此文以记之。以往只知道Linux的I/O操作有缓冲机制，但始终不知道具体的缓冲流程及使用方法。读完本章节后方才有种恍然大悟的感觉，久违的因读书而觉得舒爽的感觉。</p>
<p>好了，进入正题，下图摘自原文(13.4-I/O缓冲小结)，此图概括了<code>stdio</code>库及内核针对输出文件所用的缓冲以及各类缓冲的控制机制。本文依据此图逐步揭开文件I/O缓冲的面纱。</p>
<p><img src="/assets/linux/io_buffer.jpg" alt="I/O缓冲"></p>
<a id="more"></a>
<h2 id="I-O缓冲的类型"><a href="#I-O缓冲的类型" class="headerlink" title="I/O缓冲的类型"></a>I/O缓冲的类型</h2><p>在使用<code>stdio</code>库中文件写操作相关的函数（如:<code>printf</code>, <code>fputc</code>, <code>fputs</code>, <code>fwrite</code>）时，待写入数据从用户空间内存到内核空间内存、再到磁盘会经过以下3类缓冲</p>
<ol>
<li>stdio库的缓冲区</li>
<li>文件I/O的内核缓冲区的高速缓存</li>
<li>磁盘驱动器内置高速缓存</li>
</ol>
<p>下面逐一介绍。</p>
<h3 id="stdio库的缓冲"><a href="#stdio库的缓冲" class="headerlink" title="stdio库的缓冲"></a>stdio库的缓冲</h3><p><img src="/assets/linux/stdio_buffer.png" alt="stdio buffer"></p>
<p>如上图所示，<code>stdio</code>库实现的缓冲位于用户空间内存当中，该缓冲区A会缓冲大块的文件数据以减少系统调用（如: <code>read</code>, <code>write</code>）。</p>
<p>需要知道的是，<code>stdio</code>库函数内部会调用底层的系统调用，如<code>fgets</code>调用<code>read</code>，<code>fputs</code>调用<code>write</code>。但是在调用之前，</p>
<ul>
<li>对于读操作，库函数会先检查缓冲区A内是否已有所需数据，如果有则直接从缓冲区A读取；否则先执行系统调用<code>read</code>，从内核缓冲区B中读取数据到缓冲区A，然后从缓冲区A读取数据</li>
<li>对于写操作，库函数会先检查缓冲区A是否还有空闲，如果有则先存入缓冲区A；否则先执行库函数<code>fflush</code>，将缓冲区A中数据刷新至内核缓冲区B，然后将当前待写入数据写入缓冲区A</li>
</ul>
<p>对于<code>stdio</code>库的缓冲数据，在执行库函数之后的某一时刻，系统会通过<code>fflush</code>函数将数据刷新至内核缓冲区。当然，我们也可以手动执行<code>fflush</code>函数强制刷新数据至内核缓冲区。</p>
<p><code>fflush</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fflush(stdin)</code>会清空缓冲区内的标准输入数据</li>
<li><code>fflush(stdout)</code>会将缓冲区内的写入数据刷新至终端输出</li>
<li><code>stderr</code>默认不使用缓冲</li>
<li><code>fflush(stream)</code>将文件流<code>stream</code>的缓冲数据刷新至内核缓冲区</li>
</ul>
<h3 id="文件I-O的内核缓冲"><a href="#文件I-O的内核缓冲" class="headerlink" title="文件I/O的内核缓冲"></a>文件I/O的内核缓冲</h3><p>不管使不使用<code>stdio</code>库函数，最终都会直接或间接的调用<code>open</code>, <code>read</code>, <code>write</code>, <code>lseek</code>等系统调用读写文件I/O，那么系统就会在写操作后将数据存入内核缓冲区，但此时还并未存入磁盘。</p>
<p>也就是说，在执行<code>write</code>后，函数直接返回，但数据只是存在内核缓冲区中。当有新的读取请求时，会先在内核缓冲区中查找，如果有则直接返回；如果没有则先从磁盘读入大块数据至内核缓冲区，这样可以减少磁盘读写操作。毕竟，相比于系统调用和用户空间与内核空间之间的数据传输，磁盘读写所花费的时间要长得多。</p>
<blockquote>
<p>若内容发生变化的内核缓冲区在30s内未经显式方式同步到磁盘上，则一条长期运行的内核线程会确保将其刷新到磁盘上。</p>
</blockquote>
<p>不同版本的<code>linux</code>，其内核线程不一样，可以使用指令<code>ps aux |grep flush</code>粗略查看一下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看内核线程刷新之前脏缓冲区必须达到的时间，单位：0.01s</span></span><br><span class="line">$ cat /proc/sys/vm/dirty_expire_centisecs</span><br><span class="line">3000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核线程执行周期，单位：0.01s</span></span><br><span class="line">$ cat /proc/sys/vm/dirty_writeback_centisecs</span><br><span class="line">500</span><br></pre></td></tr></table></figure>
<h3 id="磁盘驱动器内置缓冲"><a href="#磁盘驱动器内置缓冲" class="headerlink" title="磁盘驱动器内置缓冲"></a>磁盘驱动器内置缓冲</h3><p>内核缓冲区的数据在真正存入物理磁盘前，会先存入磁盘驱动器内置的高速缓存，之后在某一时刻写入磁盘。具体过程没有深究过，目前只需知道还有这么一层缓冲区即可。</p>
<h2 id="控制文件I-O缓冲"><a href="#控制文件I-O缓冲" class="headerlink" title="控制文件I/O缓冲"></a>控制文件I/O缓冲</h2><p>通过某些方式，我们可以控制I/O缓冲机制，其中包括修改缓冲区大小、缓冲模式，禁用缓冲，强制刷新缓冲数据等。</p>
<h3 id="控制stdio库的缓冲"><a href="#控制stdio库的缓冲" class="headerlink" title="控制stdio库的缓冲"></a>控制stdio库的缓冲</h3><p>对于<code>stdio</code>库分配的缓冲区，在默认情况下会分配<code>BUFSIZ</code>大小的缓冲区，该参数值的大小说法不一，但据原文说明，在<code>glibc</code>中定义为<code>8192</code>字节。</p>
<p><code>stdio</code>流的缓冲模式分以下三类：</p>
<ul>
<li><code>_IONBF</code> - 不缓冲</li>
<li><code>_IOLBF</code> - 行缓冲，针对终端设备，在输出一个换行符前缓冲数据。对输入流，每次读取一行数据</li>
<li><code>_IOFBF</code> - 全缓冲，单词读、写数据(read, write)的大小与缓冲区大小一致，磁盘默认使用此模式</li>
</ul>
<p>我们可以通过库函数<code>setvbuf</code>, <code>setbuffer</code>, <code>setbuf</code>三者之一设置<code>stdio</code>流的缓冲模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuffer</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>setvbuf</code>函数中的mode对应的就是缓冲模式，可选项为<code>_IONBF</code>, <code>_IOLBF</code>, <code>_IOFBF</code>，<code>buf</code>和<code>size</code>分别对应指定的缓冲区指针及缓冲区大小。当然，当为不缓冲模式时，函数将忽略<code>buf</code>，<code>size</code>这两个参数。示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 4096</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line">fp = fopen(<span class="string">"test.txt"</span>, <span class="string">'w'</span>);</span><br><span class="line"><span class="keyword">if</span>(setvbuf(fp, buf, _IOFBF, BUF_SIZE) !=<span class="number">0</span> )</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure>
<p>从下面的<code>uClibc</code>源码可以看出，<code>setbuffer</code>, <code>setbuf</code>仅仅是对<code>setvbuf</code>的简单封装。但要注意的是，<code>SUSv3</code>标准并未对<code>setbuffer</code>函数加以定义，在使用时需要加上宏定义<code>_BSD_SOURCE</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuffer</span><span class="params">(FILE * __restrict stream, <span class="keyword">register</span> <span class="keyword">char</span> * __restrict buf, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STDIO_BUFFERS</span></span><br><span class="line">    setvbuf(stream, buf, (buf ? _IOFBF : _IONBF), size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE * __restrict stream, <span class="keyword">register</span> <span class="keyword">char</span> * __restrict buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STDIO_BUFFERS</span></span><br><span class="line">    setvbuf(stream, buf, ((buf != <span class="literal">NULL</span>) ? _IOFBF : _IONBF), BUFSIZ);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要禁用缓冲，通常可以使用<code>setbuf(stream, NULL)</code>实现。但通常不推荐这么做，应该合理组织代码，在特定情况使用<code>fflush</code>刷新数据，这样可以在有效利用用户空间缓冲作用的同时，减少系统调用，适宜的存储数据至内核缓冲区。</p>
<h3 id="控制文件I-O的内核缓冲"><a href="#控制文件I-O的内核缓冲" class="headerlink" title="控制文件I/O的内核缓冲"></a>控制文件I/O的内核缓冲</h3><p>在某些情况下，我们可能需要强制将内核缓冲区内的数据刷新至磁盘，而不必等待内核线程等待特定时间后才写入。此时主要有两种选择</p>
<ol>
<li>使用<code>fsync</code>，<code>fdatasync</code>, <code>sync</code>系统调用中的某一个将内核缓冲区的数据强制写入磁盘</li>
<li>以<code>O_SYNC</code>同步方式调用<code>open</code>打开文件，此后每次读写操作都会自动立即写入磁盘</li>
</ol>
<h4 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>fsync</code>保证<strong>同步I/O文件完整性</strong>，<code>fdatasync</code>保证<strong>同步I/O数据完整性</strong>。两个<strong>完整性</strong>的区别在于前者会将所有更新的文件元数据写入磁盘，后者不会传递所有经过修改的文件元数据属性（如：时间戳）。</p>
<p><code>fsync</code>与<code>fdatasync</code>均是刷新指定文件流数据，而<code>sync()</code>函数会更新所有内核缓冲区数据至磁盘，对应<code>shell</code>指令<code>sync</code>。</p>
<h4 id="O-SYNC"><a href="#O-SYNC" class="headerlink" title="O_SYNC"></a>O_SYNC</h4><p><code>fsync</code>等系统调用需要被手动调用，仅在被调用处起作用；而以<code>O_SYNC</code>方式<code>open</code>的文件流，后续所有写操作都将把数据直接写入磁盘。</p>
<p>不到万不得已还是不要以这种方式打开文件流，因为这将严重影响性能，当<code>write</code>缓冲区较小时尤为突出。</p>
<h3 id="禁用磁盘高速缓存"><a href="#禁用磁盘高速缓存" class="headerlink" title="禁用磁盘高速缓存"></a>禁用磁盘高速缓存</h3><p>按照书上描述，使用<code>hdparm -W0</code>可以禁用磁盘上的高速缓存，但我没有实际试过。</p>
<h3 id="直接I-O"><a href="#直接I-O" class="headerlink" title="直接I/O"></a>直接I/O</h3><p>当以<code>O_DIRECT</code>方式<code>open</code>文件流时，数据流会绕过内核缓冲区高速缓存，从用户空间直接传入文件或磁盘，此类过程称为<strong>直接I/O</strong>。</p>
<p>使用直接I/O对I/O操作有诸多对齐限制，主要保证读取和写入时，偏移量、数据长度以及内存边界需要是块设备基本单元(通常为512字节)的整数倍，否则会导致<code>EINVAL</code>错误。</p>
<p>使用直接I/O时，可以结合<code>memalign</code>函数动态分配内存。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用<code>stdio</code>库函数可以利用该库实现的用户空间缓冲区减少系统调用；<code>read</code>，<code>write</code>等系统调用默认不与磁盘直接传递数据，而是经过文件I/O的内核缓冲区作为中转，以此减少磁盘操作。</p>
<p>通过<code>fflush</code>函数可以将<code>stdio</code>流的缓冲区数据刷新至内核缓冲区；通过<code>fsync</code>, <code>fdatasync</code>函数可以将内核缓冲区数据刷新至磁盘。</p>
<p>使用<code>setvbuf</code>, <code>setbuf</code>等函数可以设置<code>stdio</code>流的缓冲模式，甚至禁用缓冲；以<code>O_SYNC</code>方式打开文件，可以在立即将数据同步至磁盘文件。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>《Linux/UNIX系统编程手册》 第13章 文件I/O缓冲</li>
<li><a href="http://www.pixelbeat.org/programming/stdio_buffering/" target="_blank" rel="noopener">buffering in standard streams</a></li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://www.litreily.top/2018/10/25/io-cache/" data-id="cjqcgox5f004solwtacoe7xg4" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACOElEQVR42u3awY6DMAxFUf7/pxlpVpU6wH02rQbnZoUqCDlUsuw424bH/jter19/ef/9/f6je47G9okhQ4aMxzLIdEfX5zMcfQiyBr42GTJkrMMgQfYo4NZCJ/lMZG0yZMiQ0Vl6LRGUIUOGjH7ArZW1ZB4ZMmTIOGfUQief53zOG5JOGTJkjGbUGgPfuf54f0OGDBn/nrE3BkkTeYDurEeGDBmzGeclKI9yZB7CSAvgjU8nQ4aMEYx+UtgJrLUE8Y+AK0OGjHEM/lgaHGttgGJjQIYMGaMZZNOfB8paq5Iv+uJOGTJkLMMgj5FWYud30hwtVtUyZMh4LKN2tIu/LN2YS2EyZMiYzUg36+86SNE//iVDhox1GGkiSE5k3RXE0yJZhgwZqzF40OSLSE9HkCoVHQuTIUPGwxmkJZBu8XfalrV2pgwZMmYzzh8gk/LUMG0t8KJahgwZKzD4IYm0tUlenzYMLrbbZMiQMY7RWUStqdk/Lob+BxkyZAxipNtbndysdvyrdURMhgwZgxidkrW2Gce/YhBqZciQsQAj7nzeFExrlfdFnitDhoxxDJ4IkpYnD+WdECxDhox1GHs4eCgkQTZtcB6moTJkyBjNSPfVa+Vl+vrzjyJDhow1GTwI8nyzFnbTOVHeKkOGjEGMTkuSNwnS/fygCpchQ4YMHEzTrfxa2JUhQ4YMUqamgM67UGiWIUPGAgxeWKaHJzphNNgXlCFDxmhG2hjoND5Tdv9ImQwZMh7O+AG9M3+t4vXr2QAAAABJRU5ErkJggg==">Share</a><div class="tags"><a href="/tags/stdio/">stdio</a><a href="/tags/cache/">cache</a><a href="/tags/buffer/">buffer</a></div><div class="post-nav"><a class="pre" href="/2018/12/31/pypcap-install/">Python之pypcap库的安装及简单抓包工具的实现</a><a class="next" href="/2018/09/27/tee/">Linux指令 - tee的实现</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'1ecKy4yk4u1R7C4tScKbnyq9-gzGzoHsz',
  appKey:'uvA3xgqNW3q8TGR483lxXcpB',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/LabVIEW/">LabVIEW</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Matlab/">Matlab</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Media/">Media</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Office/">Office</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/Template/">Template</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/信号处理/">信号处理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/嵌入式/">嵌入式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂物柜/">杂物柜</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/LWD/" style="font-size: 12px;">LWD</a> <a href="/tags/test/" style="font-size: 15.43px;">test</a> <a href="/tags/ruby/" style="font-size: 13.71px;">ruby</a> <a href="/tags/literature/" style="font-size: 12px;">literature</a> <a href="/tags/video/" style="font-size: 13.71px;">video</a> <a href="/tags/algorithm/" style="font-size: 20.57px;">algorithm</a> <a href="/tags/matlab/" style="font-size: 17.14px;">matlab</a> <a href="/tags/windows/" style="font-size: 13.71px;">windows</a> <a href="/tags/labview/" style="font-size: 22.29px;">labview</a> <a href="/tags/tdms/" style="font-size: 13.71px;">tdms</a> <a href="/tags/brackets/" style="font-size: 12px;">brackets</a> <a href="/tags/git/" style="font-size: 15.43px;">git</a> <a href="/tags/tools/" style="font-size: 17.14px;">tools</a> <a href="/tags/utorrent/" style="font-size: 12px;">utorrent</a> <a href="/tags/ubuntu/" style="font-size: 22.29px;">ubuntu</a> <a href="/tags/linux/" style="font-size: 18.86px;">linux</a> <a href="/tags/atom/" style="font-size: 13.71px;">atom</a> <a href="/tags/C-C/" style="font-size: 24px;">C/C++</a> <a href="/tags/signal/" style="font-size: 13.71px;">signal</a> <a href="/tags/music/" style="font-size: 13.71px;">music</a> <a href="/tags/hexo/" style="font-size: 13.71px;">hexo</a> <a href="/tags/RSS/" style="font-size: 12px;">RSS</a> <a href="/tags/Feed/" style="font-size: 12px;">Feed</a> <a href="/tags/stm32/" style="font-size: 13.71px;">stm32</a> <a href="/tags/VS/" style="font-size: 13.71px;">VS</a> <a href="/tags/office/" style="font-size: 12px;">office</a> <a href="/tags/word/" style="font-size: 12px;">word</a> <a href="/tags/jekyll/" style="font-size: 15.43px;">jekyll</a> <a href="/tags/shell/" style="font-size: 12px;">shell</a> <a href="/tags/makefile/" style="font-size: 13.71px;">makefile</a> <a href="/tags/log/" style="font-size: 12px;">log</a> <a href="/tags/wireshark/" style="font-size: 12px;">wireshark</a> <a href="/tags/tmux/" style="font-size: 13.71px;">tmux</a> <a href="/tags/telnet/" style="font-size: 12px;">telnet</a> <a href="/tags/smtp/" style="font-size: 12px;">smtp</a> <a href="/tags/mysql/" style="font-size: 12px;">mysql</a> <a href="/tags/centos/" style="font-size: 12px;">centos</a> <a href="/tags/ddos/" style="font-size: 12px;">ddos</a> <a href="/tags/hping3/" style="font-size: 12px;">hping3</a> <a href="/tags/FreeRTOS/" style="font-size: 12px;">FreeRTOS</a> <a href="/tags/spider/" style="font-size: 17.14px;">spider</a> <a href="/tags/scrapy/" style="font-size: 12px;">scrapy</a> <a href="/tags/sort/" style="font-size: 12px;">sort</a> <a href="/tags/visualization/" style="font-size: 12px;">visualization</a> <a href="/tags/queue/" style="font-size: 12px;">queue</a> <a href="/tags/xlwt/" style="font-size: 12px;">xlwt</a> <a href="/tags/pug/" style="font-size: 12px;">pug</a> <a href="/tags/lofter/" style="font-size: 12px;">lofter</a> <a href="/tags/stdio/" style="font-size: 12px;">stdio</a> <a href="/tags/cache/" style="font-size: 12px;">cache</a> <a href="/tags/buffer/" style="font-size: 12px;">buffer</a> <a href="/tags/sina/" style="font-size: 12px;">sina</a> <a href="/tags/pypcap/" style="font-size: 12px;">pypcap</a> <a href="/tags/dpkt/" style="font-size: 12px;">dpkt</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/31/pypcap-install/">Python之pypcap库的安装及简单抓包工具的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/25/io-cache/">Linux中的文件I/O缓冲</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/tee/">Linux指令 - tee的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/20/coredump/">OpenWrt中使用gdb分析coredump</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/31/pug-synax/">网页模板pug基本语法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.smslit.top" title="smslit-水木十里" target="_blank">smslit-水木十里</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">LITREILY.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> manupassant.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>